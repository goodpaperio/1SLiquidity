{
  "language": "Solidity",
  "sources": {
    "Core.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity <0.9.0 >=0.4.22 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// lib/forge-std/src/console.sol\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\n\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// src/Utils.sol\n\nlibrary Utils {\n    struct Trade {\n        address owner; //c\n        uint8 attempts; //v\n        address tokenIn; //c\n        address tokenOut; //c\n        uint256 amountIn; //c\n        uint256 amountRemaining; //v\n        uint256 targetAmountOut; //c\n        uint256 realisedAmountOut; //v\n        uint256 tradeId; //c\n        uint256 instasettleBps; //c\n        uint256 lastSweetSpot; //v\n        bool isInstasettlable; //c\n        bool usePriceBased; //c - NEW FIELD for price-based vs reserve-based DEX selection\n        bool onlyInstasettle; //c - NEW FIELD for trades that should only be settled via instasettle\n    }\n}\n\n// src/interfaces/IETHSupport.sol\n// write a contract here which is an interface alllowing the interfaced call of ETHSupport\n\ninterface IETHSupport {\n    function placeTradeWithETH(address tokenOut, uint256 amountOutMin, bool isInstasettlable, bool usePriceBased) external payable returns (uint256);\n    function placeTradeWithETHCustom(bytes calldata tradeData) external payable returns (uint256);\n    function emergencyWithdrawETH() external;\n    function emergencyWithdrawWETH() external;\n    function emergencyWithdrawToken(address token) external;\n    function getWETHBalance() external view returns (uint256);\n    function getETHBalance() external view returns (uint256);\n    function unwrap(uint256 amount, address destination) external;\n    function unwrapAndRoute(address token, address to, bytes calldata data) external;\n}\n\n// src/interfaces/IRegistry.sol\n\n/**\n * @title IRegistry\n * @notice Interface for the DEX registry that prepares trade data for different DEXs\n */\ninterface IRegistry {\n    /**\n     * @notice Structure containing all necessary data to execute a trade on any DEX\n     * @param selector The function selector to call on the executor\n     * @param router The DEX router address\n     * @param params Encoded parameters specific to the DEX\n     */\n    struct TradeData {\n        bytes4 selector;\n        address router;\n        bytes params;\n    }\n\n    /**\n     * @notice Prepares trade data for a specific DEX\n     * @param dex The DEX address (fetcher) from StreamDaemon\n     * @param tokenIn Input token address\n     * @param tokenOut Output token address\n     * @param amount Amount of input tokens\n     * @param minOut Minimum output amount\n     * @param recipient Address to receive output tokens\n     * @return Trade data containing selector, router, and encoded parameters\n     */\n    function prepareTradeData(\n        address dex,\n        address tokenIn,\n        address tokenOut,\n        uint256 amount,\n        uint256 minOut,\n        address recipient\n    ) external view returns (TradeData memory);\n}\n\n// src/interfaces/IUniversalDexInterface.sol\n\ninterface IUniversalDexInterface {\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB);\n    function getPoolAddress(address tokenIn, address tokenOut) external view returns (address pool);\n    function getDexType() external pure returns (string memory);\n    function getDexVersion() external pure returns (string memory);\n    function getPrice(address tokenIn, address tokenOut, uint256 amountIn) external view returns (uint256);\n}\n\n// src/interfaces/dex/IBalancerPool.sol\n\ninterface IBalancerPool {\n    function getPoolId() external view returns (bytes32);\n}\n\n// src/interfaces/dex/IBalancerVault.sol\n\ninterface IAsset { }\n\ninterface IBalancerVault {\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\n    \n    struct SingleSwap {\n        bytes32 poolId;\n        uint8 kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address recipient;\n        bool toInternalBalance;\n    }\n\n    function swap(SingleSwap memory singleSwap, FundManagement memory funds, uint256 limit, uint256 deadline)\n        external\n        payable\n        returns (uint256 amountCalculated);\n\n    function getPoolTokens(bytes32 poolId) external view returns (address[] memory, uint256[] memory, uint256);\n\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] calldata swaps,\n        IAsset[] calldata assets,\n        FundManagement calldata funds\n    ) external view returns (int256[] memory assetDeltas);\n}\n\n// src/interfaces/dex/ICurveMetaRegistry.sol\n\n/**\n * @title ICurveMetaRegistry\n * @dev Interface for Curve's MetaRegistry contract\n * @notice Mainnet address: 0xF98B45FA17DE75FB1aD0e7aFD971b0ca00e379fC\n */\ninterface ICurveMetaRegistry {\n    // Pool discovery\n    function find_pools_for_coins(address from, address to) external view returns (address[] memory);\n    function find_pool_for_coins(address from, address to, uint256 i) external view returns (address);\n\n    // Translate addresses to pool indices; returns (i, j, isUnderlying)\n    function get_coin_indices(address pool, address from, address to) external view\n        returns (int128, int128, bool);\n\n    // Balances (wrapped vs underlying)\n    function get_balances(address pool) external view returns (uint256[8] memory);\n    function get_underlying_balances(address pool) external view returns (uint256[8] memory);\n}\n\n// src/interfaces/dex/ICurvePool.sol\n\ninterface ICurvePool {\n    // Standard Curve pool functions\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\n\n    // Use uint256 version which is more common in newer Curve pools\n    function balances(uint256 i) external view returns (uint256);\n\n    // Pool token addresses\n    function coins(uint256 i) external view returns (address);\n\n    // Pool metadata\n    function A() external view returns (uint256);\n    function fee() external view returns (uint256);\n}\n\n// src/interfaces/dex/IOneInchV5Router.sol\n\ninterface IOneInchV5Router {\n    struct SwapDescription {\n        address srcToken;\n        address dstToken;\n        address srcReceiver;\n        address dstReceiver;\n        uint256 amount;\n        uint256 minReturnAmount;\n        uint256 flags;\n    }\n\n    /**\n     * @notice Performs a swap, delegating all calls encoded in `data` to `executor`. See tests for usage examples\n     * @param executor Aggregation executor that executes calls described in `data`\n     * @param desc Swap description\n     * @param permit Should contain valid permit that can be used in `IERC20Permit.permit` calls.\n     * @param data Encoded calls that `caller` should execute in between of swaps\n     * @return returnAmount Resulting token amount\n     * @return spentAmount Source token amount\n     */\n    function swap(address executor, SwapDescription calldata desc, bytes calldata permit, bytes calldata data)\n        external\n        payable\n        returns (uint256 returnAmount, uint256 spentAmount);\n\n    /**\n     * @notice Same as `swap` but calls permit first,\n     * allowing to approve token spending and make a swap in one transaction.\n     * Also allows to specify the receiver of the swapped tokens\n     * @param executor Aggregation executor that executes calls described in `data`\n     * @param desc Swap description\n     * @param permit Should contain valid permit that can be used in `IERC20Permit.permit` calls.\n     * @param data Encoded calls that `caller` should execute in between of swaps\n     * @return returnAmount Resulting token amount\n     * @return spentAmount Source token amount\n     */\n    function swapWithPermit(address executor, SwapDescription calldata desc, bytes calldata permit, bytes calldata data)\n        external\n        payable\n        returns (uint256 returnAmount, uint256 spentAmount);\n\n    /**\n     * @notice Performs multiple swaps in one transaction\n     * @param calls Array of encoded function calls to be executed\n     * @return results Array of results from each call\n     */\n    function batchSwap(bytes[] calldata calls) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Returns the address that should be used for token approvals\n     * @return The spender address for approvals\n     */\n    function getSpender() external view returns (address);\n}\n\n// src/interfaces/dex/IUniswapV2Router.sol\n\ninterface IUniswapV2Router {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n\n// src/interfaces/dex/IUniswapV3Router.sol\n\ninterface IUniswapV3Router {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n}\n\n// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\n// lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\n// lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\n\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n// src/adapters/BalancerV2PoolRegistry.sol\n\ninterface IBalancerV2PoolRegistry {\n    struct PoolInfo { \n        address pool; \n        bytes32 poolId; \n    }\n    \n    function getPools(address tokenA, address tokenB) external view returns (PoolInfo[] memory pools);\n    function getPrimary(address tokenA, address tokenB) external view returns (PoolInfo memory primary, bool exists);\n    function primaryIndex(address tokenA, address tokenB) external view returns (uint256);\n}\n\ncontract BalancerV2PoolRegistry is IBalancerV2PoolRegistry {\n    // --- Ownable ---\n    address public owner;\n    modifier onlyOwner() { \n        require(msg.sender == owner, \"NOT_OWNER\"); \n        _; \n    }\n    \n    constructor(address _owner) { \n        owner = _owner == address(0) ? msg.sender : _owner; \n    }\n    \n    function transferOwnership(address n) external onlyOwner { \n        owner = n; \n    }\n\n    // Optional multi-writer\n    mapping(address => bool) public isKeeper;\n    function setKeeper(address k, bool v) external onlyOwner { \n        isKeeper[k] = v; \n    }\n    \n    modifier onlyKeeperOrOwner() { \n        require(msg.sender == owner || isKeeper[msg.sender], \"NOT_AUTH\"); \n        _; \n    }\n\n    struct PairPools { \n        PoolInfo[] list; \n        uint256 primaryIdx; \n        bool exists; \n    }\n    \n    mapping(bytes32 => PairPools) private _pools;\n\n    event PoolsSet(address indexed tokenA, address indexed tokenB, uint256 count, uint256 primaryIdx);\n    event PoolAdded(address indexed tokenA, address indexed tokenB, address pool, uint256 newCount, bool primary);\n    event PoolRemoved(address indexed tokenA, address indexed tokenB, uint256 idx, uint256 newCount);\n    event PrimaryIndexSet(address indexed tokenA, address indexed tokenB, uint256 idx);\n\n    function _key(address a, address b) internal pure returns (bytes32) {\n        return (a < b) ? keccak256(abi.encodePacked(a, b)) : keccak256(abi.encodePacked(b, a));\n    }\n\n    function setPoolsForPair(address tokenA, address tokenB, address[] calldata poolAddrs, uint256 primaryIdx)\n        external onlyKeeperOrOwner\n    {\n        require(tokenA != tokenB, \"SAME_TOKEN\");\n        bytes32 key = _key(tokenA, tokenB);\n        delete _pools[key].list;\n\n        for (uint256 i = 0; i < poolAddrs.length; i++) {\n            address p = poolAddrs[i]; \n            require(p != address(0), \"POOL_0\");\n            _pools[key].list.push(PoolInfo({ \n                pool: p, \n                poolId: IBalancerPool(p).getPoolId() \n            }));\n        }\n        require(_pools[key].list.length > 0, \"NO_POOLS\");\n        require(primaryIdx < _pools[key].list.length, \"BAD_PRIMARY\");\n        _pools[key].primaryIdx = primaryIdx;\n        _pools[key].exists = true;\n        emit PoolsSet(tokenA, tokenB, _pools[key].list.length, primaryIdx);\n    }\n\n    function addPool(address tokenA, address tokenB, address pool, bool makePrimary)\n        external onlyKeeperOrOwner\n    {\n        bytes32 key = _key(tokenA, tokenB);\n        _pools[key].list.push(PoolInfo({ \n            pool: pool, \n            poolId: IBalancerPool(pool).getPoolId() \n        }));\n        _pools[key].exists = true;\n        if (makePrimary) _pools[key].primaryIdx = _pools[key].list.length - 1;\n        emit PoolAdded(tokenA, tokenB, pool, _pools[key].list.length, makePrimary);\n    }\n\n    function removePoolAt(address tokenA, address tokenB, uint256 idx) external onlyKeeperOrOwner {\n        bytes32 key = _key(tokenA, tokenB);\n        require(idx < _pools[key].list.length, \"IDX\");\n        uint256 last = _pools[key].list.length - 1;\n        if (idx != last) _pools[key].list[idx] = _pools[key].list[last];\n        _pools[key].list.pop();\n        emit PoolRemoved(tokenA, tokenB, idx, _pools[key].list.length);\n        if (_pools[key].list.length == 0) {\n            delete _pools[key];\n        } else if (_pools[key].primaryIdx >= _pools[key].list.length) {\n            _pools[key].primaryIdx = 0;\n        }\n    }\n\n    function setPrimaryIndex(address tokenA, address tokenB, uint256 idx) external onlyKeeperOrOwner {\n        bytes32 key = _key(tokenA, tokenB);\n        require(idx < _pools[key].list.length, \"BAD_PRIMARY\");\n        _pools[key].primaryIdx = idx;\n        emit PrimaryIndexSet(tokenA, tokenB, idx);\n    }\n\n    // Views\n    function getPools(address tokenA, address tokenB) external view returns (PoolInfo[] memory pools) {\n        return _pools[_key(tokenA, tokenB)].list;\n    }\n    \n    function getPrimary(address tokenA, address tokenB) external view returns (PoolInfo memory primary, bool exists) {\n        PairPools storage pp = _pools[_key(tokenA, tokenB)];\n        exists = pp.exists && pp.list.length > 0;\n        if (exists) primary = pp.list[pp.primaryIdx];\n    }\n    \n    function primaryIndex(address tokenA, address tokenB) external view returns (uint256) {\n        return _pools[_key(tokenA, tokenB)].primaryIdx;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol\n\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n\n// src/adapters/BalancerV2Fetcher.sol\n\n \n\ninterface IERC20Decimals { \n    function decimals() external view returns (uint8); \n}\n\ncontract BalancerV2Fetcher is IUniversalDexInterface {\n    IBalancerVault public immutable vault;\n    IBalancerV2PoolRegistry public immutable registry;\n\n    constructor(address _vault, address _registry) {\n        require(_vault != address(0) && _registry != address(0), \"ZERO_ADDR\");\n        vault = IBalancerVault(_vault);\n        registry = IBalancerV2PoolRegistry(_registry);\n    }\n\n    function getDexType() external pure returns (string memory) { \n        return \"BalancerV2\"; \n    }\n    \n    function getDexVersion() external pure returns (string memory) { \n        return \"V2\"; \n    }\n\n    // ========== Existing interface behavior ==========\n    function getPoolAddress(address tokenIn, address tokenOut) external view returns (address) {\n        (IBalancerV2PoolRegistry.PoolInfo memory p, bool ok) = registry.getPrimary(tokenIn, tokenOut);\n        require(ok, \"NO_POOLS\");\n        return p.pool;\n    }\n\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB) {\n        (IBalancerV2PoolRegistry.PoolInfo memory p, bool ok) = registry.getPrimary(tokenA, tokenB);\n        require(ok, \"NO_POOLS\");\n        (address[] memory tokens, uint256[] memory balances,) = vault.getPoolTokens(p.poolId);\n\n        uint256 idxA = type(uint256).max;\n        uint256 idxB = type(uint256).max;\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (tokens[i] == tokenA) idxA = i;\n            if (tokens[i] == tokenB) idxB = i;\n        }\n        require(idxA != type(uint256).max && idxB != type(uint256).max, \"TOKEN_NOT_IN_POOL\");\n        return (balances[idxA], balances[idxB]);\n    }\n\n    function getPrice(address tokenIn, address tokenOut, uint256 amountIn) external view returns (uint256) {\n        require(amountIn > 0, \"AMOUNT_0\");\n        IBalancerV2PoolRegistry.PoolInfo[] memory pools = registry.getPools(tokenIn, tokenOut);\n        require(pools.length > 0, \"NO_POOLS\");\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(tokenIn);\n        assets[1] = IAsset(tokenOut);\n\n        IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement({\n            sender: address(this),\n            fromInternalBalance: false,\n            recipient: payable(address(this)),\n            toInternalBalance: false\n        });\n\n        uint256 bestOut = 0;\n        for (uint256 i = 0; i < pools.length; i++) {\n            IBalancerVault.BatchSwapStep[] memory steps = new IBalancerVault.BatchSwapStep[](1);\n            steps[0] = IBalancerVault.BatchSwapStep({\n                poolId: pools[i].poolId,\n                assetInIndex: 0,\n                assetOutIndex: 1,\n                amount: amountIn,\n                userData: \"\"\n            });\n            int256[] memory deltas = vault.queryBatchSwap(IBalancerVault.SwapKind.GIVEN_IN, steps, assets, funds);\n            if (deltas.length >= 2 && deltas[1] < 0) {\n                uint256 outAmt = uint256(-deltas[1]);\n                if (outAmt > bestOut) bestOut = outAmt;\n            }\n        }\n        return bestOut; // 0 means no quote\n    }\n\n    // ========== Extra helpers (non-breaking) ==========\n\n    /// @notice Returns the pool with the greatest pairwise depth (min(normalized balances))\n    function getDeepestPool(address tokenA, address tokenB) external view returns (address pool, bytes32 poolId) {\n        IBalancerV2PoolRegistry.PoolInfo[] memory pools = registry.getPools(tokenA, tokenB);\n        require(pools.length > 0, \"NO_POOLS\");\n\n        uint256 bestScore = 0;\n        for (uint256 i = 0; i < pools.length; i++) {\n            (address[] memory tokens, uint256[] memory balances,) = vault.getPoolTokens(pools[i].poolId);\n\n            // find indices\n            uint256 idxA = type(uint256).max; \n            uint256 idxB = type(uint256).max;\n            for (uint256 j = 0; j < tokens.length; j++) {\n                if (tokens[j] == tokenA) idxA = j;\n                if (tokens[j] == tokenB) idxB = j;\n            }\n            if (idxA == type(uint256).max || idxB == type(uint256).max) continue; // skip non-members\n\n            // normalize by decimals \u2192 18 decimals\n            uint256 nA = _normalize(balances[idxA], _decimals(tokenA));\n            uint256 nB = _normalize(balances[idxB], _decimals(tokenB));\n\n            uint256 score = nA < nB ? nA : nB;\n            if (score > bestScore) {\n                bestScore = score;\n                pool = pools[i].pool;\n                poolId = pools[i].poolId;\n            }\n        }\n        require(bestScore > 0, \"NO_DEPTH\");\n    }\n\n    /// @notice Returns (bestOut, pool) using Balancer's own math (queryBatchSwap)\n    function getBestPriceAndPool(address tokenIn, address tokenOut, uint256 amountIn)\n        external view returns (uint256 bestOut, address pool)\n    {\n        require(amountIn > 0, \"AMOUNT_0\");\n        IBalancerV2PoolRegistry.PoolInfo[] memory pools = registry.getPools(tokenIn, tokenOut);\n        require(pools.length > 0, \"NO_POOLS\");\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(tokenIn);\n        assets[1] = IAsset(tokenOut);\n\n        IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement({\n            sender: address(this), \n            fromInternalBalance: false,\n            recipient: payable(address(this)), \n            toInternalBalance: false\n        });\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            IBalancerVault.BatchSwapStep[] memory steps = new IBalancerVault.BatchSwapStep[](1);\n            steps[0] = IBalancerVault.BatchSwapStep({\n                poolId: pools[i].poolId, \n                assetInIndex: 0, \n                assetOutIndex: 1, \n                amount: amountIn, \n                userData: \"\"\n            });\n            int256[] memory deltas = vault.queryBatchSwap(IBalancerVault.SwapKind.GIVEN_IN, steps, assets, funds);\n            if (deltas.length >= 2 && deltas[1] < 0) {\n                uint256 outAmt = uint256(-deltas[1]);\n                if (outAmt > bestOut) { \n                    bestOut = outAmt; \n                    pool = pools[i].pool; \n                }\n            }\n        }\n    }\n\n    // ---------- utils ----------\n    function _decimals(address token) internal view returns (uint8 d) {\n        // default 18 if token doesn't implement decimals()\n        (bool ok, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20Decimals.decimals.selector));\n        d = (ok && data.length >= 32) ? abi.decode(data, (uint8)) : 18;\n    }\n    \n    function _normalize(uint256 amt, uint8 dec) internal pure returns (uint256) {\n        // scale to 1e18 with divide-first to avoid overflow\n        if (dec == 18) return amt;\n        if (dec > 18) return amt / (10 ** (dec - 18));\n        return amt * (10 ** (18 - dec));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\n\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n\n// src/StreamDaemon.sol\n\ncontract StreamDaemon is Ownable {\n    IUniversalDexInterface public universalDexInterface;\n    address[] public dexs; // @audit following eternal storage pattern may go to Core.sol\n    mapping(address => address) public dexToRouters; // goes to Core.sol\n\n    event DEXRouteAdded(address indexed dex);\n    event DEXRouteRemoved(address indexed dex);\n\n    // temporarily efine a constant for minimum effective gas in dollars\n    // uint256 public constant MIN_EFFECTIVE_GAS_DOLLARS = 1; // i.e $1 minimum @audit this should be valuated against\n        // TOKEN-USDC value during execution in production\n    uint256 public DEFAULT_SWEET_SPOT = 4;\n\n    constructor(address[] memory _dexs, address[] memory _routers) Ownable(msg.sender) {\n        for (uint256 i = 0; i < _dexs.length; i++) {\n            dexs.push(_dexs[i]);\n        }\n        for (uint256 i = 0; i < _routers.length; i++) {\n            dexToRouters[_dexs[i]] = _routers[i];\n        } // @audit make sure to pass the routers in the appropriate order wrt how the dex's are inputted on deployment\n    }\n\n    function setDefaultSweetSpot(uint256 _defaultSweetSpot) external onlyOwner {\n        DEFAULT_SWEET_SPOT = _defaultSweetSpot;\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function registerDex(address _fetcher) external onlyOwner {\n        dexs.push(_fetcher); // @audit this storage allocation has multiple dependancies in order to actually function,\n            // including deployments of appropriate fetchers and configuration of the relevant dex's interface\n        emit DEXRouteAdded(_fetcher);\n    }\n\n    function removeDex(address _fetcher) external onlyOwner {\n        for (uint256 i = 0; i < dexs.length; i++) {\n            if (dexs[i] == _fetcher) {\n                dexs[i] = dexs[dexs.length - 1];\n                dexs.pop();\n                delete dexToRouters[_fetcher];\n                emit DEXRouteRemoved(_fetcher);\n                break;\n            }\n        }\n    }\n\n    function evaluateSweetSpotAndDex(\n        address tokenIn,\n        address tokenOut,\n        uint256 volume,\n        uint256 effectiveGas,\n        bool usePriceBased\n    )\n        public\n        view\n        returns (uint256 sweetSpot, address bestFetcher, address router)\n    {\n        address identifiedFetcher;\n        uint256 maxReserveIn;\n        uint256 maxReserveOut;\n\n        // lets implement this conditional: if (tokenOut == 0x0000000000000000000000000000000000000000 | 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee) { let tokenOut == WETH }\n        if (tokenOut == 0x0000000000000000000000000000000000000000 || tokenOut == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n            tokenOut = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // drop address in here @ethsupport\n        }\n\n        if (usePriceBased) {\n            // Price-based DEX selection\n            (identifiedFetcher, maxReserveIn, maxReserveOut) = findBestPriceForTokenPair(tokenIn, tokenOut, volume);\n            bestFetcher = identifiedFetcher;\n            router = dexToRouters[bestFetcher];\n        } else {\n            // Reserve-based DEX selection\n            (identifiedFetcher, maxReserveIn, maxReserveOut) = findHighestReservesForTokenPair(tokenIn, tokenOut);\n            bestFetcher = identifiedFetcher;\n            router = dexToRouters[bestFetcher];\n        }\n\n        sweetSpot = _sweetSpotAlgo(tokenIn, tokenOut, volume, bestFetcher);\n    }\n\n    function findBestPriceForTokenPair(\n        address tokenIn,\n        address tokenOut,\n        uint256 volume\n    )\n        public\n        view\n        returns (address bestFetcher, uint256 maxReserveIn, uint256 maxReserveOut)\n    {\n        uint256 bestPrice = type(uint256).max;\n\n        for (uint256 i = 0; i < dexs.length; i++) {\n            IUniversalDexInterface fetcher = IUniversalDexInterface(dexs[i]);\n\n            try fetcher.getPrice(tokenIn, tokenOut, volume) returns (uint256 price) {\n                // Only consider non-zero prices\n                if (price > 0 && price < bestPrice) {\n                    bestPrice = price;\n                    bestFetcher = address(fetcher);\n\n                    // Get reserves for sweet spot calculation\n                    try fetcher.getReserves(tokenIn, tokenOut) returns (uint256 reserveIn, uint256 reserveOut) {\n                        maxReserveIn = reserveIn;\n                        maxReserveOut = reserveOut;\n                    } catch {\n                        // If getReserves fails, we still have the best price\n                    }\n                }\n            } catch {\n                // Skip if price fetch fails\n            }\n        }\n        require(bestFetcher != address(0), \"No DEX found for token pair\");\n    }\n\n    /**\n     * @dev always written in terms of\n     *  **the token that is being added to the pool** (tokenIn)\n     */\n    function findHighestReservesForTokenPair(\n        address tokenIn,\n        address tokenOut\n    )\n        public\n        view\n        returns (address bestFetcher, uint256 maxReserveIn, uint256 maxReserveOut)\n    {\n        for (uint256 i = 0; i < dexs.length; i++) {\n            IUniversalDexInterface fetcher = IUniversalDexInterface(dexs[i]);\n            try fetcher.getReserves(tokenIn, tokenOut) returns (uint256 reserveTokenIn, uint256 reserveTokenOut) {\n                if (reserveTokenIn > maxReserveIn && reserveTokenIn > 0) {\n                    maxReserveIn = reserveTokenIn;\n                    maxReserveOut = reserveTokenOut;\n                    bestFetcher = address(fetcher);\n                }\n            } catch Error(string memory reason) {\n                reason;\n            }\n            // catch (bytes memory lowLevelData) {\n            // }\n        }\n        require(bestFetcher != address(0), \"No DEX found for token pair\");\n    }\n\n    /**\n     * @dev Sweet Spot Algorithm v4 - Using constant product formula (x*y=k)\n     * Simple iterative approach: double sweet spot until slippage < 10 BPS\n     */\n    function _sweetSpotAlgo(\n        address tokenIn,\n        address tokenOut,\n        uint256 volume,\n        address bestFetcher\n    )\n        public\n        view\n        returns (uint256 sweetSpot)\n    {\n        // Step 1: Read reserves from the DEX\n        (uint256 reserveIn, uint256 reserveOut) = IUniversalDexInterface(bestFetcher).getReserves(tokenIn, tokenOut);\n\n        if (reserveIn == 0 || reserveOut == 0) {\n            revert(\"Zero reserves\");\n            // return 4; // Fallback to minimum sweet spot\n        }\n        uint256 actualReserveIn = reserveIn;\n        uint256 actualReserveOut = reserveOut;\n        uint256 actualVolume = volume;\n\n        sweetSpot = 1;\n\n        uint256 effectiveVolume = actualVolume / sweetSpot;\n        uint256 slippage = _calculateSlippage(effectiveVolume, actualReserveIn, actualReserveOut);\n\n        // @audit for alpha testing purposes, we minimise sweet spot to 4. In production, this  should be removed\n\n        if (slippage <= 10) {\n            sweetSpot = DEFAULT_SWEET_SPOT;\n            return sweetSpot;\n        }\n\n        // iteratively double sweet spot until slippage < 10 BPS\n        uint256 lastSweetSpot = sweetSpot;\n        uint256 lastSlippage = slippage;\n\n        while (slippage > 10 && sweetSpot < 1000) {\n            // cap at 1000 to prevent infinite loops\n            lastSweetSpot = sweetSpot;\n            lastSlippage = slippage;\n\n            sweetSpot = sweetSpot * 2;\n            effectiveVolume = actualVolume / sweetSpot;\n\n            // ensure we don't divide by zero\n            if (effectiveVolume == 0) {\n                break;\n            }\n\n            slippage = _calculateSlippage(effectiveVolume, actualReserveIn, actualReserveOut);\n        }\n\n        // binary search refinement if we crossed the target threshold\n        if (lastSlippage > 10 && slippage <= 10) {\n            uint256 low = lastSweetSpot;\n            uint256 high = sweetSpot;\n\n            for (uint256 i = 0; i < 5; i++) {\n                uint256 mid = (low + high) / 2;\n                uint256 midVolume = actualVolume / mid;\n\n                if (midVolume == 0) {\n                    break;\n                }\n\n                uint256 midSlippage = _calculateSlippage(midVolume, actualReserveIn, actualReserveOut);\n\n                if (midSlippage <= 10) {\n                    high = mid;\n                    sweetSpot = mid;\n                } else {\n                    low = mid;\n                }\n            }\n        }\n\n        // @audit for alpha testing purposes, we regulate sweet spot between 4 and 500. In production, this  should be\n        // removed\n        if (sweetSpot <= 4) {\n            sweetSpot = DEFAULT_SWEET_SPOT;\n        }\n        if (sweetSpot > 500) {\n            sweetSpot = 500;\n        }\n    }\n\n    /**\n     * @dev Calculate slippage using constant product formula (x*y=k) for v4\n     */\n    function _calculateSlippage(\n        uint256 volumeIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    )\n        internal\n        pure\n        returns (uint256 slippageBps)\n    {\n        // All values are now actual token amounts (not raw decimals)\n\n        // k = reserveIn * reserveOut\n        uint256 k = reserveIn * reserveOut;\n\n        // volumeOut = reserveOut - (k / (reserveIn + volumeIn))\n        uint256 denominator = reserveIn + volumeIn;\n\n        if (denominator == 0) {\n            return 0; // Return 0 slippage to prevent division by zero\n        }\n\n        uint256 volumeOut = reserveOut - (k / denominator);\n\n        // Realized price = volumeOut / volumeIn (actual token amounts)\n        // We need to scale for precision in the ratio calculation\n        uint256 realizedPrice = volumeOut;\n        uint256 realizedPriceBase = volumeIn;\n\n        // Observed price = reserveOut / reserveIn (actual token amounts)\n        uint256 observedPrice = reserveOut;\n        uint256 observedPriceBase = reserveIn;\n\n        // Calculate slippage: 1 - (realizedPrice / observedPrice)\n        // priceRatio = (realizedPrice / realizedPriceBase) / (observedPrice / observedPriceBase)\n        // priceRatio = (realizedPrice * observedPriceBase) / (realizedPriceBase * observedPrice)\n\n        if (realizedPriceBase == 0 || observedPrice == 0) {\n            return 0; // Return 0 slippage to prevent division by zero\n        }\n\n        uint256 priceRatio = (realizedPrice * observedPriceBase * 10_000) / (realizedPriceBase * observedPrice);\n\n        // If priceRatio > 10000, it means we're getting a better price (negative slippage), set to 0\n        if (priceRatio > 10_000) {\n            slippageBps = 0;\n        } else {\n            slippageBps = 10_000 - priceRatio; // Slippage in basis points\n        }\n    }\n}\n\n// src/Executor.sol\n\n// import {StreamDaemon} from \"./StreamDaemon.sol\";\n// let's rather use safeApprove from openzeppelin\n\ncontract Executor {\n    using SafeERC20 for IERC20;\n\n    error ZeroAmount();\n    error SwapFailed();\n\n    event TradeExecuted(address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    function executeUniswapV2Trade(\n        bytes memory params // @audit consider adding validation for params length\n    ) external returns (uint256) {\n        // Decode all parameters\n        (address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOutMin, address recipient, address router) =\n            abi.decode(params, (address, address, uint256, uint256, address, address));\n\n        if (amountIn == 0) revert ZeroAmount();\n\n        IERC20(tokenIn).forceApprove(router, amountIn);\n\n        address[] memory path = new address[](2);\n        path[0] = tokenIn;\n        path[1] = tokenOut;\n\n        uint256[] memory amounts = IUniswapV2Router(router).swapExactTokensForTokens(\n            amountIn,\n            amountOutMin,\n            path,\n            recipient,\n            block.timestamp + 300 // @audit standardize deadline across all DEXes\n        );\n\n        // @audit consider additional validation on amountOut\n        emit TradeExecuted(tokenIn, tokenOut, amountIn, amounts[amounts.length - 1]); // @audit consider adding more\n            // event data\n        return amounts[amounts.length - 1];\n    }\n\n    function executeUniswapV3Trade(\n        bytes memory params // @audit consider adding validation for params length\n    ) external returns (uint256) {\n        // Decode all parameters\n        (\n            address tokenIn,\n            address tokenOut,\n            uint256 amountIn,\n            uint256 amountOutMin,\n            address recipient,\n            uint24 fee,\n            uint160 sqrtPriceLimitX96,\n            address router\n        ) = abi.decode(params, (address, address, uint256, uint256, address, uint24, uint160, address));\n\n        if (amountIn == 0) revert ZeroAmount();\n\n        IERC20(tokenIn).forceApprove(router, amountIn);\n\n        IUniswapV3Router.ExactInputSingleParams memory swapParams = IUniswapV3Router.ExactInputSingleParams({\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            fee: fee,\n            recipient: recipient, // @audit verify recipient is not zero address\n            deadline: block.timestamp + 300, // @audit standardize deadline across all DEXes\n            amountIn: amountIn,\n            amountOutMinimum: amountOutMin, // @audit consider minimum slippage threshold\n            sqrtPriceLimitX96: sqrtPriceLimitX96 // @audit document impact of this parameter\n        });\n\n        uint256 amountOut = IUniswapV3Router(router).exactInputSingle(swapParams);\n\n        // @audit consider additional validation on amountOut\n        emit TradeExecuted(tokenIn, tokenOut, amountIn, amountOut); // @audit consider adding more event data\n            // (recipient, fee)\n        return amountOut;\n    }\n\n    function executeBalancerTrade(\n        bytes memory params // @audit consider adding validation for params length\n    ) external returns (uint256) {\n        // Decode all parameters - router is actually the fetcher address\n        (\n            address tokenIn,\n            address tokenOut,\n            uint256 amountIn,\n            uint256 amountOutMin,\n            address recipient, // @audit verify recipient is not zero address\n            address fetcherAddress\n        ) = abi.decode(params, (address, address, uint256, uint256, address, address));\n\n        if (amountIn == 0) revert ZeroAmount();\n\n        // Get the BalancerV2Fetcher to find the best pool\n        BalancerV2Fetcher fetcher = BalancerV2Fetcher(fetcherAddress);\n        \n        // Use deepest reserves by default (not price-based selection)\n        // The StreamDaemon should select the appropriate DEX based on usePriceBased flag\n        (address deepestPool, bytes32 poolId) = fetcher.getDeepestPool(tokenIn, tokenOut);\n        require(deepestPool != address(0), \"No valid pool found\");\n        address balancerVault = address(fetcher.vault());\n\n        IERC20(tokenIn).forceApprove(balancerVault, amountIn);\n\n        IBalancerVault.SingleSwap memory singleSwap = IBalancerVault.SingleSwap({\n            poolId: poolId,\n            kind: 0, // GIVEN_IN @audit check if this is the correct kind\n            assetIn: tokenIn,\n            assetOut: tokenOut,\n            amount: amountIn,\n            userData: \"\" // @audit document what userData could be used for\n        });\n\n        IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement({\n            sender: address(this), // Use this contract (Core via delegatecall) as sender since it owns the tokens\n            fromInternalBalance: false,\n            recipient: recipient,\n            toInternalBalance: false\n        });\n\n        // Execute the swap and get the exact amount returned by Balancer Vault\n        uint256 amountOut = IBalancerVault(balancerVault).swap(singleSwap, funds, amountOutMin, block.timestamp + 300);\n\n        // @audit consider additional validation on amountOut\n        emit TradeExecuted(tokenIn, tokenOut, amountIn, amountOut); // @audit consider adding more event data\n        return amountOut;\n    }\n\n    function executeCurveTrade(\n        bytes memory params // @audit consider adding validation for params length\n    ) external returns (uint256) {\n        // Decode all parameters - Registry now encodes 8 parameters including tokenOut\n        (\n            address tokenIn,\n            address tokenOut,\n            int128 i,\n            int128 j,\n            uint256 amountIn,\n            uint256 amountOutMin,\n            address recipient, // @audit verify recipient is not zero address\n            address router\n        ) = abi.decode(params, (address, address, int128, int128, uint256, uint256, address, address));\n\n        if (amountIn == 0) revert ZeroAmount();\n\n        console.log(\"Executor: Starting Curve trade\");\n        console.log(\"tokenIn:\", tokenIn);\n        console.log(\"tokenOut:\", tokenOut);\n        console.log(\"amountIn:\", amountIn);\n        console.log(\"amountOutMin:\", amountOutMin);\n        console.log(\"recipient:\", recipient);\n        console.log(\"router:\", router);\n\n        // Approve the token being traded, not the pool\n        IERC20(tokenIn).forceApprove(router, amountIn); // @audit should we reset approval to 0 first?\n\n        // Get initial balance of output token to calculate difference\n        uint256 initialBalance = IERC20(tokenOut).balanceOf(address(this));\n        console.log(\"Initial balance of tokenOut:\", initialBalance);\n\n        // Execute the Curve exchange using low-level call to handle reverts\n        // Some Curve pools revert after successful execution, so we need to check balances\n        (bool success,) =\n            router.call(abi.encodeWithSelector(ICurvePool.exchange.selector, i, j, amountIn, amountOutMin));\n\n        // Don't check success - Curve pools can revert after successful execution\n        // We'll verify success by checking if tokens were actually transferred\n\n        // Check final balance to get actual amount received\n        uint256 finalBalance = IERC20(tokenOut).balanceOf(address(this));\n        console.log(\"Final balance of tokenOut:\", finalBalance);\n\n        uint256 actualAmountOut = finalBalance - initialBalance;\n        console.log(\"Actual amount out calculated:\", actualAmountOut);\n\n        // Validate that tokens were actually transferred\n        require(actualAmountOut > 0, \"No tokens received from Curve exchange\");\n        console.log(\"Passed first require check\");\n\n        require(actualAmountOut >= amountOutMin, \"Insufficient output amount\");\n        console.log(\"Passed second require check\");\n\n        // @audit consider additional validation on amountOut\n        emit TradeExecuted(tokenIn, tokenOut, amountIn, actualAmountOut); // @audit consider adding more event data\n        console.log(\"TradeExecuted event emitted, returning:\", actualAmountOut);\n        return actualAmountOut;\n    }\n\n    function executeCurveMetaTrade(\n        bytes memory params\n    ) external returns (uint256) {\n        // Decode parameters for CurveMeta (no hardcoded indices)\n        (\n            address tokenIn,\n            address tokenOut,\n            uint256 amountIn,\n            uint256 amountOutMin,\n            address recipient,\n            address router\n        ) = abi.decode(params, (address, address, uint256, uint256, address, address));\n\n        if (amountIn == 0) revert ZeroAmount();\n\n        console.log(\"Executor: Starting CurveMeta trade\");\n        console.log(\"tokenIn:\", tokenIn);\n        console.log(\"tokenOut:\", tokenOut);\n        console.log(\"amountIn:\", amountIn);\n        console.log(\"amountOutMin:\", amountOutMin);\n        console.log(\"recipient:\", recipient);\n        console.log(\"router:\", router);\n\n        // Get the CurveMetaFetcher to find the best pool and indices\n        // The router should be the CurveMetaFetcher address\n        ICurveMetaRegistry metaRegistry = ICurveMetaRegistry(0xF98B45FA17DE75FB1aD0e7aFD971b0ca00e379fC);\n        \n        // Find the best pool for this token pair\n        address[] memory pools = metaRegistry.find_pools_for_coins(tokenIn, tokenOut);\n        require(pools.length > 0, \"No Curve pools found for token pair\");\n        \n        address bestPool = address(0);\n        int128 bestI = 0;\n        int128 bestJ = 0;\n        bool bestIsUnderlying = false;\n        uint256 bestScore = 0;\n        \n        // Find the pool with the highest depth (min of the two reserves)\n        for (uint256 p = 0; p < pools.length; p++) {\n            address pool = pools[p];\n            if (pool == address(0)) continue;\n            \n            (int128 i, int128 j, bool isUnderlying) = metaRegistry.get_coin_indices(pool, tokenIn, tokenOut);\n            if (i < 0 || j < 0) continue;\n            \n            // Calculate depth score\n            uint256[8] memory balances = isUnderlying \n                ? metaRegistry.get_underlying_balances(pool)\n                : metaRegistry.get_balances(pool);\n            \n            uint256 reserveA = balances[uint256(int256(i))];\n            uint256 reserveB = balances[uint256(int256(j))];\n            uint256 score = reserveA < reserveB ? reserveA : reserveB;\n            \n            if (score > bestScore) {\n                bestScore = score;\n                bestPool = pool;\n                bestI = i;\n                bestJ = j;\n                bestIsUnderlying = isUnderlying;\n            }\n        }\n        \n        require(bestPool != address(0), \"No suitable Curve pool found\");\n        console.log(\"Selected pool:\", bestPool);\n        console.log(\"Coin indices:\", uint256(int256(bestI)), uint256(int256(bestJ)));\n        console.log(\"Is underlying:\", bestIsUnderlying);\n\n        // Approve the token being traded\n        IERC20(tokenIn).forceApprove(bestPool, amountIn);\n\n        // Get initial balance of output token to calculate difference\n        uint256 initialBalance = IERC20(tokenOut).balanceOf(address(this));\n        console.log(\"Initial balance of tokenOut:\", initialBalance);\n\n        // Execute the Curve exchange\n        // Use exchange_underlying if it's an underlying token trade\n        bool success;\n        if (bestIsUnderlying) {\n            (success,) = bestPool.call(abi.encodeWithSignature(\n                \"exchange_underlying(int128,int128,uint256,uint256)\",\n                bestI, bestJ, amountIn, amountOutMin\n            ));\n        } else {\n            (success,) = bestPool.call(abi.encodeWithSignature(\n                \"exchange(int128,int128,uint256,uint256)\",\n                bestI, bestJ, amountIn, amountOutMin\n            ));\n        }\n\n        // Check final balance to get actual amount received\n        uint256 finalBalance = IERC20(tokenOut).balanceOf(address(this));\n        console.log(\"Final balance of tokenOut:\", finalBalance);\n\n        uint256 actualAmountOut = finalBalance - initialBalance;\n        console.log(\"Actual amount out calculated:\", actualAmountOut);\n\n        // Validate that tokens were actually transferred\n        require(actualAmountOut > 0, \"No tokens received from Curve exchange\");\n        require(actualAmountOut >= amountOutMin, \"Insufficient output amount\");\n\n        emit TradeExecuted(tokenIn, tokenOut, amountIn, actualAmountOut);\n        console.log(\"TradeExecuted event emitted, returning:\", actualAmountOut);\n        return actualAmountOut;\n    }\n\n    function executeOneInchTrade(\n        bytes memory params // @audit consider adding validation for params length\n    ) external returns (uint256) {\n        // Decode all parameters - now including 1inch-specific data\n        (\n            address tokenIn,\n            address tokenOut,\n            uint256 amountIn,\n            uint256 amountOutMin,\n            address recipient,\n            address router,\n            address executor,\n            bytes memory swapData\n        ) = abi.decode(params, (address, address, uint256, uint256, address, address, address, bytes));\n\n        if (amountIn == 0) revert ZeroAmount();\n\n        // Approve the token being traded to the 1inch router\n        IERC20(tokenIn).forceApprove(router, amountIn);\n\n        // Get initial balance of output token to calculate difference\n        uint256 initialBalance = IERC20(tokenOut).balanceOf(address(this));\n\n        // Prepare 1inch swap description\n        IOneInchV5Router.SwapDescription memory desc = IOneInchV5Router.SwapDescription({\n            srcToken: tokenIn,\n            dstToken: tokenOut,\n            srcReceiver: address(this), // This contract receives the source tokens\n            dstReceiver: recipient, // Recipient receives the output tokens\n            amount: amountIn,\n            minReturnAmount: amountOutMin,\n            flags: 0 // Default flags\n        });\n\n        // Execute the 1inch swap\n        // Note: In a real implementation, the swapData would come from the 1inch API\n        // For testing purposes, we'll use a simplified approach\n        try IOneInchV5Router(router).swap(\n            executor, // 1inch executor address (would come from API)\n            desc, // Swap description\n            \"\", // No permit data\n            swapData // Encoded swap data (would come from 1inch API)\n        ) returns (uint256 returnAmount, uint256 spentAmount) {\n            // Check that we received the expected amount\n            require(returnAmount >= amountOutMin, \"Insufficient output amount\");\n\n            emit TradeExecuted(tokenIn, tokenOut, spentAmount, returnAmount);\n            return returnAmount;\n        } catch {\n            // Fallback: If 1inch swap fails, we can't proceed\n            revert(\"OneInch swap failed - invalid executor or swap data\");\n        }\n    }\n}\n\n// src/Core.sol\n\n// import \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\n// import interface for @ethsupport\n\ncontract Core is Ownable, ReentrancyGuard /*, UUPSUpgradeable */ {\n    using SafeERC20 for IERC20;\n\n    // @audit must be able to recieve and transfer tokens\n    StreamDaemon public streamDaemon;\n    Executor public executor;\n    IRegistry public registry;\n    IETHSupport public ethSupport;\n    \n    // WETH address on mainnet\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    error ToxicTrade(uint256 tradeId);\n\n    event TradeCreated(\n        uint256 indexed tradeId,\n        address indexed user,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountRemaining,\n        uint256 minAmountOut,\n        uint256 realisedAmountOut,\n        bool isInstasettlable,\n        uint256 instasettleBps,\n        uint256 lastSweetSpot,\n        bool usePriceBased,\n        bool onlyInstasettle\n    );\n\n    event TradeStreamExecuted(\n        uint256 indexed tradeId, uint256 amountIn, uint256 realisedAmountOut, uint256 lastSweetSpot\n    );\n\n    event TradeCancelled(bool isAutocancelled, uint256 indexed tradeId, uint256 amountRemaining, uint256 realisedAmountOut);\n\n    event TradeInstasettled(\n        uint256 indexed tradeId,\n        address indexed settler,\n        uint256 totalAmountIn,\n        uint256 totalAmountOut,\n        uint256 totalFees\n    );\n\n    event TradeCompleted(\n        uint256 indexed tradeId,\n        uint256 finalRealisedAmountOut\n    );\n\n    event LowLevelError(string error);\n\n    event DataError(bytes error);\n\n    // =========================\n    // Fees state\n    // =========================\n    uint16 public constant MAX_BPS = 10_000;\n    uint16 public constant MAX_FEE_CAP_BPS = 100; // 1%\n    uint16 public streamProtocolFeeBps = 10; // 10 bps\n    uint16 public streamBotFeeBps = 10; // 10 bps\n    uint16 public instasettleProtocolFeeBps = 10; // 10 bps\n\n    uint256 public EXECUTE_STREAM_TRADE_CAP = 20; // 20 stream execution cap on executeTrades set at deployment\n\n    // Protocol fee balances by token\n    mapping(address => uint256) public protocolFees;\n\n    // Fees events\n    event StreamFeesTaken(\n        uint256 indexed tradeId, address indexed bot, address indexed token, uint256 protocolFee, uint256 botFee\n    );\n    event InstasettleFeeTaken(\n        uint256 indexed tradeId, address indexed settler, address indexed token, uint256 protocolFee\n    );\n    event FeesClaimed(address indexed recipient, address indexed token, uint256 amount, bool isProtocol);\n    event FeeRatesUpdated(uint16 streamProtocolFeeBps, uint16 streamBotFeeBps, uint16 instasettleProtocolFeeBps);\n\n    // trades\n    uint256 public lastTradeId;\n    mapping(bytes32 => uint256[]) public pairIdTradeIds;\n    mapping(uint256 => uint256) public tradeIndicies;\n    mapping(uint256 => Utils.Trade) public trades;\n\n    // balances\n    mapping(address => mapping(address => uint256)) public eoaTokenBalance;\n    mapping(address => uint256) public modulusResiduals;\n\n    constructor(address _streamDaemon, address _executor, address _registry, address _ethSupport) Ownable(msg.sender) {\n        streamDaemon = StreamDaemon(_streamDaemon);\n        executor = Executor(_executor);\n        registry = IRegistry(_registry);\n        ethSupport = IETHSupport(_ethSupport);\n    }\n\n    function _computeFee(uint256 amount, uint16 bps) internal pure returns (uint256) {\n        return (amount * bps) / MAX_BPS;\n    }\n\n    function _applyStreamFees(uint256 tradeId, address tokenOut, uint256 deltaOut, bool isInitial, address bot)\n        internal\n        returns (uint256 protocolFee, uint256 botFee)\n    {\n        if (deltaOut == 0) {\n            return (0, 0);\n        }\n        protocolFee = _computeFee(deltaOut, streamProtocolFeeBps);\n        botFee = _computeFee(deltaOut, streamBotFeeBps);\n        if (isInitial) {\n            protocolFee += botFee;\n            botFee = 0;\n        }\n        // Guard: bot fee cannot exceed 100 bps of delta\n        require(botFee * MAX_BPS <= deltaOut * 100, \"bot fee guard\");\n        protocolFees[tokenOut] += protocolFee;\n        emit StreamFeesTaken(tradeId, bot, tokenOut, protocolFee, botFee);\n    }\n\n    function _removeTradeFromStorage(bytes32 pairId, uint256 tradeId) internal {\n        uint256[] storage tradeIds = pairIdTradeIds[pairId];\n        uint256 tradeIndex = tradeIndicies[tradeId];\n        Utils.Trade memory lastTrade = trades[tradeIds.length - 1]; \n        trades[tradeIndex] = lastTrade;\n        tradeIds.pop();\n        tradeIndicies[lastTradeId] = tradeIndex; \n        delete tradeIndicies[tradeId];\n        delete trades[tradeId];\n    }\n\n    /**\n     * @notice Set the ETHSupport contract address\n     * @dev Only callable by owner, needed to resolve circular dependency during deployment\n     * @param _ethSupport The ETHSupport contract address\n     */\n    function setETHSupport(address _ethSupport) external onlyOwner {\n        require(_ethSupport != address(0), \"ETHSupport cannot be zero address\");\n        ethSupport = IETHSupport(_ethSupport);\n    }\n\n    function setExecuteStreamCap(uint256 _newCap) public onlyOwner {\n        EXECUTE_STREAM_TRADE_CAP = _newCap;\n    }\n    \n    function setStreamProtocolFeeBps(uint16 bps) external onlyOwner {\n        require(bps <= MAX_FEE_CAP_BPS, \"fee cap\");\n        streamProtocolFeeBps = bps;\n        emit FeeRatesUpdated(streamProtocolFeeBps, streamBotFeeBps, instasettleProtocolFeeBps);\n    }\n\n    function setStreamBotFeeBps(uint16 bps) external onlyOwner {\n        require(bps <= MAX_FEE_CAP_BPS, \"fee cap\");\n        streamBotFeeBps = bps;\n        emit FeeRatesUpdated(streamProtocolFeeBps, streamBotFeeBps, instasettleProtocolFeeBps);\n    }\n\n    function setInstasettleProtocolFeeBps(uint16 bps) external onlyOwner {\n        require(bps <= MAX_FEE_CAP_BPS, \"fee cap\");\n        instasettleProtocolFeeBps = bps;\n        emit FeeRatesUpdated(streamProtocolFeeBps, streamBotFeeBps, instasettleProtocolFeeBps);\n    }\n\n    function claimProtocolFees(address token) external onlyOwner nonReentrant {\n        uint256 amount = protocolFees[token];\n        require(amount > 0, \"no fees\");\n        protocolFees[token] = 0;\n        IERC20(token).safeTransfer(owner(), amount);\n        emit FeesClaimed(owner(), token, amount, true);\n    }\n\n    function setStreamDaemon(address _streamDaemon) external onlyOwner {\n        require(_streamDaemon != address(0), \"Invalid address\");\n        streamDaemon = StreamDaemon(_streamDaemon);\n    }\n\n    function setExecutor(address _executor) external onlyOwner {\n        require(_executor != address(0), \"Invalid address\");\n        executor = Executor(_executor);\n    }\n\n    function setRegistry(address _registry) external onlyOwner {\n        require(_registry != address(0), \"Invalid address\");\n        registry = IRegistry(_registry);\n    }\n\n    function instasettle(uint256 tradeId) external nonReentrant {\n        Utils.Trade memory trade = trades[tradeId];\n        bytes32 pairId = keccak256(abi.encode(trade.tokenIn, trade.tokenOut));\n        require(trade.owner != address(0), \"Trade not found\");\n        require(trade.isInstasettlable, \"Trade not instasettlable\");\n        \n        // otheriwse, remove trade from storage and settle amounts\n        _removeTradeFromStorage(pairId, tradeId);\n        // Note: _removeTradeFromStorage already handles deletion of all three storage locations\n        // Calculate remaining amount that needs to be settled\n        uint256 remainingAmountOut = trade.targetAmountOut - trade.realisedAmountOut;\n        require(remainingAmountOut > 0, \"No remaining amount to settle\");\n\n        // Calculate how much the settler should pay\n        // targetAmountOut - (realisedAmountOut * (1 - instasettleBps/10000))\n        uint256 settlerPayment =\n            ((trade.targetAmountOut - trade.realisedAmountOut) * (10_000 - trade.instasettleBps)) / 10_000;\n\n        // Check if tokenOut is ETH sentinel\n        bool isETHSentinel = (trade.tokenOut == 0x0000000000000000000000000000000000000000 || trade.tokenOut == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE));\n        \n        // Take protocol fee from settler on instasettle\n        uint256 protocolFee = _computeFee(settlerPayment, instasettleProtocolFeeBps);\n        if (protocolFee > 0) {\n            if (isETHSentinel) {\n                // For ETH output, require ETH payment for protocol fee\n                // Note: Core will receive WETH from the user, we need to handle this differently\n                // For now, reduce the settler payment by the protocol fee and add to Core's balance\n                IERC20(WETH).safeTransferFrom(msg.sender, address(this), protocolFee);\n                protocolFees[address(WETH)] += protocolFee;\n            } else {\n                IERC20(trade.tokenOut).safeTransferFrom(msg.sender, address(this), protocolFee);\n                protocolFees[trade.tokenOut] += protocolFee;\n            }\n            emit InstasettleFeeTaken(trade.tradeId, msg.sender, trade.tokenOut, protocolFee);\n        }\n\n        // Unwrap and transfer to owner if ETH sentinel, otherwise transfer token\n        if (isETHSentinel) {\n            // For ETH output: unwrap the settlerPayment amount to send to owner\n            // The settler should have sent WETH already which is in Core\n            ethSupport.unwrap(settlerPayment, trade.owner);\n        } else {    \n            IERC20(trade.tokenOut).safeTransferFrom(msg.sender, trade.owner, settlerPayment);\n        }\n        IERC20(trade.tokenIn).safeTransfer(msg.sender, trade.amountRemaining);\n        emit TradeInstasettled(\n            trade.tradeId,\n            msg.sender,\n            trade.amountRemaining,\n            settlerPayment,\n            remainingAmountOut - settlerPayment // totalFees is the difference (logical fee notion)\n        );\n    }\n\n    function getPairIdTradeIds(bytes32 pairId) external view returns (uint256[] memory) {\n        return pairIdTradeIds[pairId];\n    }\n\n    function getTrade(uint256 tradeId) external view returns (Utils.Trade memory) {\n        Utils.Trade memory trade = trades[tradeId];\n        require(trade.owner != address(0), \"Trade not found\");\n        return trade;\n    }\n\n    function placeTrade(bytes calldata tradeData) public payable {\n        (\n            address tokenIn,\n            address tokenOut,\n            uint256 amountIn,\n            uint256 amountOutMin,\n            bool isInstasettlable,\n            bool usePriceBased,\n            uint256 instasettleBps,\n            bool onlyInstasettle\n        ) = abi.decode(tradeData, (address, address, uint256, uint256, bool, bool, uint256, bool));\n        // @audit may be better to abstract sweetSpot algo to here and pass the value along, since small (<0.001% pool depth) trades shouldn't be split at all and would save hefty logic\n        // @audit edge cases wrt pool depths (specifically extremely small volume to volume reserves) create anomalies in the algo output\n        // @audit similarly for the sake of OPTIMISTIC and DETERMINISTIC placement patterns, we should abstract the calculation of sweetSpot nad the definition of appropriate DEX into seperated, off contract functions\n        IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        uint256 tradeId = lastTradeId++;\n        bytes32 pairId = keccak256(abi.encode(tokenIn, tokenOut)); //@audit optimise this\n\n        // @audit needs attention for small trades - these hsouldn't be entered in the orderbook / storage\n        trades[tradeId] = Utils.Trade({\n            owner: msg.sender,\n            attempts: 0,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            amountIn: amountIn,\n            amountRemaining: amountIn,\n            targetAmountOut: amountOutMin,\n            realisedAmountOut: 0,\n            tradeId: tradeId,\n            instasettleBps: instasettleBps,\n            lastSweetSpot: onlyInstasettle ? type(uint256).max : 0, \n            isInstasettlable: isInstasettlable,\n            usePriceBased: usePriceBased,\n            onlyInstasettle: onlyInstasettle\n        });\n        \n\n        pairIdTradeIds[pairId].push(tradeId);\n        uint256 tradeIndex = pairIdTradeIds[pairId].length - 1;\n        tradeIndicies[tradeId] = tradeIndex;\n\n        Utils.Trade storage trade = trades[tradeId];\n        uint256 realisedBefore = trade.realisedAmountOut;\n        Utils.Trade memory updatedTrade = executeStream(trade.tradeId);\n        uint256 delta = updatedTrade.realisedAmountOut - realisedBefore; // initial delta = realised\n        if (delta > 0) {\n            (uint256 protocolFee, uint256 botFee) = _applyStreamFees(tradeId, tokenOut, delta, true, address(0));\n            trades[tradeId].realisedAmountOut = updatedTrade.realisedAmountOut - (protocolFee + botFee);\n        }\n\n        // Emit TradeCreated event after stream execution with actual values\n        emit TradeCreated(\n            tradeId,\n            msg.sender,\n            tokenIn,\n            tokenOut,\n            amountIn,\n            updatedTrade.amountRemaining, // Use actual remaining amount after stream\n            amountOutMin,\n            updatedTrade.realisedAmountOut, // Use actual realised amount after stream\n            isInstasettlable,\n            instasettleBps, // Use the passed instasettleBps parameter\n            updatedTrade.lastSweetSpot, // Use actual sweet spot utilized\n            usePriceBased,\n            onlyInstasettle\n        );\n    }\n\n    function cancelTrade(uint256 tradeId) public returns (bool) {\n        // @audit It is essential that this authority may be granted by a bot, therefore meaning if the msg.sender is\n        // Core.\n        // @audit Similarly, when the Router is implemented, we mnust forward the msg.sender in the function call /\n        // veridy signed message\n        Utils.Trade memory trade = trades[tradeId];\n        if (trade.owner == address(0)) {\n            revert(\"Trade inexistent or being called from null address\");\n        }\n        if (trade.owner == msg.sender || msg.sender == address(this)) {\n            // @ethsupport here we would unwrap if tokenOut == 0x0.000 // function unwrap\n\n            bytes32 pairId = keccak256(abi.encode(trade.tokenIn, trade.tokenOut));\n            \n            _removeTradeFromStorage(pairId, tradeId);\n            \n            // If tokenOut is ETH sentinel, unwrap WETH to ETH before transferring\n            if (trade.tokenOut == 0x0000000000000000000000000000000000000000 || trade.tokenOut == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n                ethSupport.unwrap(trade.realisedAmountOut, trade.owner); // @ethsupport ensure that unwrap is payable in interface\n            } else {\n                IERC20(trade.tokenOut).safeTransfer(trade.owner, trade.realisedAmountOut);\n            }\n            \n            IERC20(trade.tokenIn).safeTransfer(trade.owner, trade.amountRemaining);\n\n            bool autoCancelled = msg.sender == address(this) ? true : false;\n\n            emit TradeCancelled(autoCancelled, tradeId, trade.amountRemaining, trade.realisedAmountOut);\n\n            return true;\n        } else {\n            revert(\"Only trade owner can cancel\");\n        }\n    }\n\n    function executeTrades(bytes32 pairId) public nonReentrant {\n        uint256[] storage tradeIds = pairIdTradeIds[pairId];\n        uint256 botFeesAccrued = 0;\n        address tokenOutForRun = address(0);\n\n        // Cap the number of trades processed to prevent out of gas errors\n        // uint256 maxTradesToProcess = EXECUTE_STREAM_TRADE_CAP;\n        uint256 tradesToProcess = tradeIds.length > EXECUTE_STREAM_TRADE_CAP ? EXECUTE_STREAM_TRADE_CAP : tradeIds.length;\n\n        // Process trades in reverse order to avoid array index issues when trades are deleted\n        for (uint256 i = tradesToProcess; i > 0; i--) {\n            uint256 index = i - 1; // Convert to 0-based index\n            Utils.Trade storage trade = trades[tradeIds[index]];\n            if (trade.attempts >= 3) {\n                // we transfer the remaining amount of the trade to the owner and dequeue it via cancelTrade\n                this.cancelTrade(trade.tradeId);\n            } else {\n                uint256 realisedBefore = trade.realisedAmountOut;\n                try this.executeStream(trade.tradeId) returns (Utils.Trade memory updatedTrade) {\n                    uint256 delta = updatedTrade.realisedAmountOut - realisedBefore;\n                    if (delta > 0) {\n                        if (tokenOutForRun == address(0)) tokenOutForRun = updatedTrade.tokenOut;\n                        (uint256 protocolFee, uint256 botFee) =\n                            _applyStreamFees(trade.tradeId, updatedTrade.tokenOut, delta, false, msg.sender);\n                        trades[trade.tradeId].realisedAmountOut =\n                            updatedTrade.realisedAmountOut - (protocolFee + botFee);\n                        botFeesAccrued += botFee;\n                    }\n                    if (updatedTrade.lastSweetSpot == 0) {\n                        // @ethsupport here we would unwrap if tokenOut == 0x0.000 // function unwrap\n                        if (trade.tokenOut == 0x0000000000000000000000000000000000000000 || trade.tokenOut == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n                            ethSupport.unwrap(trades[trade.tradeId].realisedAmountOut, trade.owner);\n                        } else {\n                            IERC20(trade.tokenOut).safeTransfer(trade.owner, trades[trade.tradeId].realisedAmountOut);\n                        }\n                        emit TradeCompleted(trade.tradeId, trades[trade.tradeId].realisedAmountOut);\n                        _removeTradeFromStorage(pairId, tradeIds[index]);\n                    }\n                } catch Error(string memory reason) {\n                    trade.attempts++;\n                    emit LowLevelError(reason);\n                } catch (bytes memory lowLevelData) {\n                    trade.attempts++;\n                    emit DataError(lowLevelData);\n                }\n            }\n        }\n\n        if (botFeesAccrued > 0) {\n            // require(tokenOutForRun != address(0), \"fee token unset\");\n            if (tokenOutForRun == 0x0000000000000000000000000000000000000000 || tokenOutForRun == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n                // transfer ETH to the bot address (msg.sender)\n                (bool success, ) = payable(msg.sender).call{value: botFeesAccrued}(\"\");\n                require(success, \"ETH transfer failed\");\n            } else {\n            IERC20(tokenOutForRun).safeTransfer(msg.sender, botFeesAccrued);\n            }\n            emit FeesClaimed(msg.sender, tokenOutForRun, botFeesAccrued, false);\n        }\n    }\n    \n\n    function executeStream(uint256 tradeId) public returns (Utils.Trade memory updatedTrade) {\n        Utils.Trade storage storageTrade = trades[tradeId];\n        Utils.Trade memory trade = trades[tradeId];\n\n        // Early return for onlyInstasettle trades - they should only be settled via instasettle()\n        if (trade.onlyInstasettle) {\n            // Set lastSweetSpot to sentinel value to prevent auto-settlement in executeTrades\n            return storageTrade;\n        }\n\n        // security measure @audit may need review\n        // if (trade.realisedAmountOut > trade.targetAmountOut) {\n        //     revert ToxicTrade(trade.tradeId);\n        // }\n\n        (uint256 sweetSpot, address bestDex, address router) = streamDaemon.evaluateSweetSpotAndDex(\n            trade.tokenIn, trade.tokenOut, trade.amountRemaining, 0, trade.usePriceBased\n        );\n\n        if (\n            trade.lastSweetSpot == 1 || trade.lastSweetSpot == 2 || trade.lastSweetSpot == 3 || trade.lastSweetSpot == 4\n        ) {\n            sweetSpot = trade.lastSweetSpot;\n        }\n\n        if (sweetSpot > 500) {\n            sweetSpot = 500; // this is an arbitrary value @audit needs revision\n        }\n\n        require(sweetSpot > 0, \"Invalid sweet spot\");\n        uint256 targetAmountOut;\n        uint256 streamVolume;\n        if (trade.targetAmountOut > trade.realisedAmountOut) {\n            targetAmountOut = (trade.targetAmountOut - trade.realisedAmountOut) / sweetSpot * 996 / 1000; // dropping 0.4% to allow for DEX fees\n            streamVolume = trade.amountRemaining / sweetSpot;\n        } else {\n            targetAmountOut = trade.realisedAmountOut - trade.targetAmountOut;\n\n            // ! @audit maybe we need to do some smart maths here to determine the exchange rate at time of trade placement and propogate that\n            // if the amount remaining is really tiny and the target amount out is large the tradde will fail, esp due to changing market conditions?\n            sweetSpot = 1;\n            streamVolume = trade.amountRemaining;\n        }\n\n        // Declare tradeData outside the if-else block so it's in scope\n        IRegistry.TradeData memory tradeData;\n        \n        if (trade.tokenOut == 0x0000000000000000000000000000000000000000 || trade.tokenOut == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n            // this sets the trading currency to WETH if the desired tokenOut is native ETH\n            tradeData = registry.prepareTradeData(\n                bestDex, trade.tokenIn, address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), streamVolume, targetAmountOut, address(this)\n            );\n            \n        } else {\n            tradeData = registry.prepareTradeData(\n                bestDex, trade.tokenIn, trade.tokenOut, streamVolume, targetAmountOut, address(this)\n            );\n        }\n\n        IERC20(trade.tokenIn).forceApprove(tradeData.router, streamVolume);\n\n        (bool success, bytes memory returnData) =\n            address(executor).delegatecall(abi.encodeWithSelector(tradeData.selector, tradeData.params));\n        if (!success) {\n            revert(string(abi.encodePacked(\"DEX trade failed: \", returnData)));\n        }\n        uint256 amountOut = abi.decode(returnData, (uint256));\n        require(amountOut > 0, \"No tokens received from swap\");\n\n        // @dev protection for the case that an EOA has called executeStream\n        if (sweetSpot == 1 && msg.sender != address(this)) {\n            bytes32 pairId = keccak256(abi.encode(trade.tokenIn, trade.tokenOut));\n            IERC20(trade.tokenOut).safeTransfer(trade.owner, trade.realisedAmountOut);                        \n            _removeTradeFromStorage(pairId, trade.tradeId);\n            return storageTrade;\n        }\n\n        if (sweetSpot == 1 || sweetSpot == 2 || sweetSpot == 3 || sweetSpot == 4) {\n            sweetSpot--;\n        }\n\n        storageTrade.amountRemaining = trade.amountRemaining - streamVolume;\n        storageTrade.realisedAmountOut += amountOut;\n        storageTrade.lastSweetSpot = sweetSpot;\n\n        emit TradeStreamExecuted(trade.tradeId, streamVolume, amountOut, sweetSpot);\n\n        return storageTrade;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "shanghai",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode"
        ]
      }
    }
  }
}